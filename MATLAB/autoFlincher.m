%autoFlincher.m
%
% A script to automatically generate flinch data based on a pre-computed
% level set. The flinch data is generated by using a bounded normal distribution
% to randomly sample a level value at which the flinch will occur for a given
% run. The parameters of this distribution can be adjusted at the top of this
% script.

%% Control rng seed
seed = 42;
rng(seed);

%% Set parameters
valueMean = 0;
valueStd = 0.1;
valueLowerBound = valueMean - 0.5;
valueUpperBound = valueMean + 0.5;

initialConditions = [-2.25:0.25:2.25, -2.25:0.25:2.25];
initialConditions = initialConditions(randperm(length(initialConditions)));

familyDataFile = 'dubinsFamily.mat';
familyDataIndex = 6;

saveFlinches = true;
flinchesDataFile = 'autoFlinches.mat';

%% Create the probability distribution
normalDistribution = makedist('Normal', 'mu', valueMean, 'sigma', valueStd);
truncatedNormalDistribution = ...
  truncate(normalDistribution, valueLowerBound, valueUpperBound);

%% Load the level set data
familyData = load(familyDataFile);
gridData = familyData.gridDataFamily{familyDataIndex};
values = familyData.valuesFamily{familyDataIndex};

% Dimension indices
xIndex = 1;
yIndex = 2;
thetaIndex = 3;

%% Simple flincher test dynamics
dt = 0.01; % s
t_stop = 2; % s
v = 3; % m/s (constant Dubins velocity)
x_0 = -5; % m (inital distance from obstacle)
y_0 = 0; % m (this will vary for every run)
theta_0 = 0; % rad (this will be constant)

%% Run the flinch trials
numTrials = length(initialConditions);
flinchPoints = [];
flinchLevels = [];
for i = 1:numTrials
  % Set run-specific parameters
  y_0 = initialConditions(i);
  flinchLevel = random(truncatedNormalDistribution);
  
  % Initialize the system
  x = x_0;
  y = y_0;
  theta = theta_0;
  
  % Run the physics until time elapses or flinch occurs
  for t = [1 : (t_stop / dt)]
    % Find grid point corresponding to this state
    [~, xCoordinate] = min(abs(x - gridData.vs{xIndex}));
    [~, yCoordinate] = min(abs(y - gridData.vs{yIndex}));
    [~, thetaCoordinate] = min(abs(theta - gridData.vs{thetaIndex}));
    
    % Find the value function at this state
    value = values(xCoordinate, yCoordinate, thetaCoordinate);
    
    % Determine flinch
    if value < flinchLevel
      flinchPoints(:, end + 1) = [x; y; theta];
      flinchLevels(end + 1) = flinchLevel;
      break;
    end
    
    % Advance the physics
    x = x + v * cos(theta) * dt;
    y = y + v * sin(theta) * dt;
    theta = theta;
  end
end

%% Plot the results
if true
    flinchData.flinchPoints = flinchPoints;
    plotFlinchesOverValueFromFamily(flinchData, familyData, ...
                                    familyDataIndex, thetaCoordinate);
end

%% Save the flinch points, if desired
if saveFlinches
  save(flinchesDataFile, 'flinchPoints');
end