%autoFlincher.m
%
% A script to automatically generate flinch data based on a pre-computed
% level set. The flinch data is generated by using a bounded normal distribution
% to randomly sample a level value at which the flinch will occur for a given
% run. The parameters of this distribution can be adjusted at the top of this
% script.

%% Control rng seed
seed = 42;
rng(seed);

%% Set parameters
valueMean = 0;
valueStd = 0.1;
valueLowerBound = valueMean - 0.5;
valueUpperBound = valueMean + 0.5;

initialConditions = [-2.25:0.25:2.25, -2.25:0.25:2.25];
initialConditions = initialConditions(randperm(length(initialConditions)));

familyDataFile = 'dubinsFamily.mat';
familyDataIndex = 3;

saveFlinches = true;
flinchesDataFile = 'autoFlinches.mat';

%% Create the probability distribution
normalDistribution = makedist('Normal', 'mu', valueMean, 'sigma', valueStd);
truncatedNormalDistribution = ...
  truncate(normalDistribution, valueLowerBound, valueUpperBound);

%% Load the level set data
familyData = load(familyDataFile);
gridData = familyData.gridDataFamily{familyDataIndex};
values = familyData.valuesFamily{familyDataIndex};

% Dimension indices
xIndex = 1;
yIndex = 2;
thetaIndex = 3;

%% Simple flincher test dynamics
dt = 0.01; % s
t_stop = 2; % s
v = 3; % m/s (constant Dubins velocity)
x_0 = -5; % m (inital distance from obstacle)
y_0 = 0; % m (this will vary for every run)
theta_0 = 0; % rad (this will be constant)

%% Run the flinch trials
numTrials = length(initialConditions);
flinchPoints = [];
flinchLevels = [];
for i = 1:numTrials
  % Set run-specific parameters
  y_0 = initialConditions(i);
  flinchLevel = random(truncatedNormalDistribution);
  
  % Initialize the system
  x = x_0;
  y = y_0;
  theta = theta_0;
  
  % Run the physics until time elapses or flinch occurs
  for t = [1 : (t_stop / dt)]
    % Find grid point corresponding to this state
    [~, xCoordinate] = min(abs(x - gridData.vs{xIndex}));
    [~, yCoordinate] = min(abs(y - gridData.vs{yIndex}));
    [~, thetaCoordinate] = min(abs(theta - gridData.vs{thetaIndex}));
    
    % Find the value function at this state
    value = values(xCoordinate, yCoordinate, thetaCoordinate);
    
    % Determine flinch
    if value < flinchLevel
      flinchPoints(:, end + 1) = [x; y; theta];
      flinchLevels(end + 1) = flinchLevel;
      break;
    end
    
    % Advance the physics
    x = x + v * cos(theta) * dt;
    y = y + v * sin(theta) * dt;
    theta = theta;
  end
end

%% Plot the results
if true
    % New figure
    figure;
    hold on;
    
    % Use the value function data as background
    image('XData', gridData.vs{1}, 'YData', gridData.vs{2}, ...
          'CData',values(:, :, thetaCoordinate)','CDataMapping','scaled');
        
    % Show the contour lines
    contour(gridData.vs{1}, gridData.vs{2}, values(:, :, thetaCoordinate)', ...
            'k', 'LineWidth', 2);
    
    % Plot the flinch points
    plot(flinchPoints(1,:), flinchPoints(2,:), 'ro', 'LineWidth', 2)
    
    % Label the theta value for this plot
    title(['\theta = ', num2str(gridData.vs{thetaIndex}(thetaCoordinate))]);
    axis equal;
    hold off;
end

%% Save the flinch points, if desired
if saveFlinches
  save(flinchesDataFile, 'flinchPoints');
end